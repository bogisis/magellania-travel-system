// ===== VUE ROUTER –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =====
// src/router/index.js

import { createRouter, createWebHistory } from 'vue-router'
import { useEstimateStore } from '@/stores/estimateStore'
import { useToastStore } from '@/stores/toastStore'

// Lazy loading –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
const HomePage = () => import('@/pages/HomePage.vue')
const EstimatesPage = () => import('@/pages/EstimatesPage.vue')
const EstimateEditor = () => import('@/pages/EstimateEditor.vue')
const OptionalServicesPage = () => import('@/pages/OptionalServicesPage.vue')
const PreviewPage = () => import('@/pages/PreviewPage.vue')
const SettingsPage = () => import('@/pages/SettingsPage.vue')
const NotFoundPage = () => import('@/pages/NotFoundPage.vue')

const routes = [
  {
    path: '/',
    name: 'Home',
    component: HomePage,
    meta: {
      title: '–ì–ª–∞–≤–Ω–∞—è',
      icon: 'üè†',
      showInNav: true
    }
  },
  {
    path: '/estimates',
    name: 'Estimates',
    component: EstimatesPage,
    meta: {
      title: '–°–º–µ—Ç—ã',
      icon: 'üìä',
      showInNav: true
    }
  },
  {
    path: '/estimate/:id?',
    name: 'EstimateEditor',
    component: EstimateEditor,
    meta: {
      title: '–†–µ–¥–∞–∫—Ç–æ—Ä —Å–º–µ—Ç—ã',
      icon: '‚úèÔ∏è',
      showInNav: true,
      requiresEstimate: false // –ú–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—É—é —Å–º–µ—Ç—É
    },
    beforeEnter: (to, from, next) => {
      const estimateStore = useEstimateStore()
      
      if (to.params.id) {
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Å–º–µ—Ç—É
        const estimate = estimateStore.loadEstimate(to.params.id)
        if (!estimate) {
          const toastStore = useToastStore()
          toastStore.error('–û—à–∏–±–∫–∞', '–°–º–µ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞')
          return next('/estimates')
        }
      } else {
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–º–µ—Ç—É
        estimateStore.createNewEstimate()
      }
      
      next()
    }
  },
  {
    path: '/optional-services',
    name: 'OptionalServices', 
    component: OptionalServicesPage,
    meta: {
      title: '–î–æ–ø. —É—Å–ª—É–≥–∏',
      icon: '‚≠ê',
      showInNav: true
    }
  },
  {
    path: '/preview/:id?',
    name: 'Preview',
    component: PreviewPage,
    meta: {
      title: '–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä',
      icon: 'üëÅÔ∏è',
      showInNav: true,
      requiresEstimate: true
    },
    beforeEnter: (to, from, next) => {
      const estimateStore = useEstimateStore()
      const estimateId = to.params.id || estimateStore.currentEstimateId
      
      if (!estimateId || !estimateStore.loadEstimate(estimateId)) {
        const toastStore = useToastStore()
        toastStore.warning('–í–Ω–∏–º–∞–Ω–∏–µ', '–í—ã–±–µ—Ä–∏—Ç–µ —Å–º–µ—Ç—É –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞')
        return next('/estimates')
      }
      
      next()
    }
  },
  {
    path: '/settings',
    name: 'Settings',
    component: SettingsPage,
    meta: {
      title: '–ù–∞—Å—Ç—Ä–æ–π–∫–∏',
      icon: '‚öôÔ∏è',
      showInNav: false
    }
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: NotFoundPage,
    meta: {
      title: '–°—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
      showInNav: false
    }
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes,
  scrollBehavior(to, from, savedPosition) {
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é —Å–∫—Ä–æ–ª–ª–∞ –∏–ª–∏ —Å–∫—Ä–æ–ª–ª–∏–º –≤–≤–µ—Ä—Ö
    if (savedPosition) {
      return savedPosition
    } else {
      return { top: 0 }
    }
  }
})

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ guards
router.beforeEach((to, from, next) => {
  // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
  document.title = to.meta.title ? 
    `${to.meta.title} - Magellania Travel System` : 
    'Magellania Travel System'
  
  next()
})

router.afterEach((to, from) => {
  // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
  console.log(`Navigated from ${from.name} to ${to.name}`)
})

export default router

// ===== COMPOSABLES =====

// src/composables/useEstimates.js
import { ref, computed } from 'vue'
import { useEstimateStore } from '@/stores/estimateStore'
import { useToastStore } from '@/stores/toastStore'
import { calculationService } from '@/services/calculationService'

export function useEstimates() {
  const estimateStore = useEstimateStore()
  const toastStore = useToastStore()
  
  const isLoading = ref(false)
  const error = ref(null)

  // –í—ã—á–∏—Å–ª—è–µ–º—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞
  const estimates = computed(() => estimateStore.estimates)
  const currentEstimate = computed(() => estimateStore.currentEstimate)
  const estimatesCount = computed(() => estimateStore.estimatesCount)

  // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Å–º–µ—Ç—É
  const createEstimate = async (initialData = {}) => {
    try {
      isLoading.value = true
      const estimate = estimateStore.createNewEstimate(initialData)
      toastStore.success('–£—Å–ø–µ—Ö', '–ù–æ–≤–∞—è —Å–º–µ—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞')
      return estimate
    } catch (err) {
      error.value = err.message
      toastStore.error('–û—à–∏–±–∫–∞', '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–º–µ—Ç—É')
      throw err
    } finally {
      isLoading.value = false
    }
  }

  // –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–º–µ—Ç—É
  const loadEstimate = async (estimateId) => {
    try {
      isLoading.value = true
      const estimate = estimateStore.loadEstimate(estimateId)
      if (!estimate) {
        throw new Error('–°–º–µ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞')
      }
      return estimate
    } catch (err) {
      error.value = err.message
      toastStore.error('–û—à–∏–±–∫–∞', err.message)
      throw err
    } finally {
      isLoading.value = false
    }
  }

  // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–º–µ—Ç—É
  const saveEstimate = async (estimate = null) => {
    try {
      isLoading.value = true
      await estimateStore.saveEstimate(estimate)
      return true
    } catch (err) {
      error.value = err.message
      throw err
    } finally {
      isLoading.value = false
    }
  }

  // –£–¥–∞–ª–∏—Ç—å —Å–º–µ—Ç—É
  const deleteEstimate = async (estimateId) => {
    try {
      isLoading.value = true
      await estimateStore.deleteEstimate(estimateId)
      toastStore.success('–£—Å–ø–µ—Ö', '–°–º–µ—Ç–∞ —É–¥–∞–ª–µ–Ω–∞')
      return true
    } catch (err) {
      error.value = err.message
      toastStore.error('–û—à–∏–±–∫–∞', '–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–º–µ—Ç—É')
      throw err
    } finally {
      isLoading.value = false
    }
  }

  // –î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å —Å–º–µ—Ç—É
  const duplicateEstimate = async (estimateId) => {
    try {
      isLoading.value = true
      const original = estimates.value.find(est => est.id === estimateId)
      if (!original) {
        throw new Error('–°–º–µ—Ç–∞ –¥–ª—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞')
      }

      const duplicate = {
        ...original,
        id: undefined, // –ë—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π ID
        name: `${original.name} (–∫–æ–ø–∏—è)`,
        tourInfo: {
          ...original.tourInfo,
          tourName: `${original.tourInfo.tourName} (–∫–æ–ø–∏—è)`
        },
        status: 'draft',
        createdAt: undefined,
        modifiedAt: undefined
      }

      const newEstimate = estimateStore.createNewEstimate(duplicate)
      toastStore.success('–£—Å–ø–µ—Ö', '–°–º–µ—Ç–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∞')
      return newEstimate
    } catch (err) {
      error.value = err.message
      toastStore.error('–û—à–∏–±–∫–∞', '–ù–µ —É–¥–∞–ª–æ—Å—å –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å —Å–º–µ—Ç—É')
      throw err
    } finally {
      isLoading.value = false
    }
  }

  return {
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ
    isLoading,
    error,
    
    // –í—ã—á–∏—Å–ª—è–µ–º—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞
    estimates,
    currentEstimate,
    estimatesCount,
    
    // –ú–µ—Ç–æ–¥—ã
    createEstimate,
    loadEstimate,
    saveEstimate,
    deleteEstimate,
    duplicateEstimate
  }
}

// src/composables/useCalculations.js
import { computed } from 'vue'
import { calculationService } from '@/services/calculationService'
import { currencyService } from '@/services/currencyService'

export function useCalculations(estimate) {
  // –ë–∞–∑–æ–≤—ã–µ —Ä–∞—Å—á–µ—Ç—ã
  const subtotal = computed(() => {
    if (!estimate?.value) return 0
    return calculationService.calculateTotal(estimate.value)
  })

  const detailedCalculation = computed(() => {
    if (!estimate?.value) return null
    return calculationService.calculateDetailedTotal(estimate.value)
  })

  // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  const formattedSubtotal = computed(() => {
    const currency = estimate?.value?.currency || 'USD'
    return currencyService.formatAmount(subtotal.value, currency)
  })

  const formattedTotal = computed(() => {
    const currency = estimate?.value?.currency || 'USD'
    const calculation = detailedCalculation.value
    return calculation ? currencyService.formatAmount(calculation.total, currency) : '$0.00'
  })

  // –†–∞—Å—á–µ—Ç —Ä–µ–Ω—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç–∏
  const profitability = computed(() => {
    if (!estimate?.value) return null
    return calculationService.calculateProfitability(estimate.value)
  })

  // –í–∞–ª–∏–¥–∞—Ü–∏—è
  const validation = computed(() => {
    if (!estimate?.value) return { valid: false, errors: [], warnings: [] }
    return calculationService.validateEstimate(estimate.value)
  })

  // –ú–µ—Ç–æ–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –æ—Ç–¥–µ–ª—å–Ω—ã–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
  const calculateDayTotal = (day) => {
    return calculationService.calculateDayTotal(day)
  }

  const calculateItemTotal = (item) => {
    return calculationService.calculateItemTotal(item)
  }

  const formatAmount = (amount, currency = 'USD') => {
    return currencyService.formatAmount(amount, currency)
  }

  return {
    // –í—ã—á–∏—Å–ª—è–µ–º—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞
    subtotal,
    detailedCalculation,
    formattedSubtotal,
    formattedTotal,
    profitability,
    validation,
    
    // –ú–µ—Ç–æ–¥—ã
    calculateDayTotal,
    calculateItemTotal,
    formatAmount
  }
}

// src/composables/useToast.js
import { useToastStore } from '@/stores/toastStore'

export function useToast() {
  const toastStore = useToastStore()

  const success = (title, message, options = {}) => {
    return toastStore.success(title, message, options)
  }

  const error = (title, message, options = {}) => {
    return toastStore.error(title, message, options)
  }

  const warning = (title, message, options = {}) => {
    return toastStore.warning(title, message, options)
  }

  const info = (title, message, options = {}) => {
    return toastStore.info(title, message, options)
  }

  const remove = (toastId) => {
    return toastStore.removeToast(toastId)
  }

  const clear = () => {
    return toastStore.clearAllToasts()
  }

  return {
    success,
    error,
    warning,
    info,
    remove,
    clear
  }
}

// src/composables/useModal.js
import { ref } from 'vue'

export function useModal(initiallyOpen = false) {
  const isOpen = ref(initiallyOpen)
  const data = ref(null)

  const open = (modalData = null) => {
    data.value = modalData
    isOpen.value = true
  }

  const close = () => {
    isOpen.value = false
    data.value = null
  }

  const toggle = () => {
    isOpen.value ? close() : open()
  }

  return {
    isOpen,
    data,
    open,
    close,
    toggle
  }
}

// src/composables/useDebounce.js
import { ref, watch } from 'vue'

export function useDebounce(value, delay = 300) {
  const debouncedValue = ref(value.value)

  let timeout = null

  watch(value, (newValue) => {
    if (timeout) {
      clearTimeout(timeout)
    }

    timeout = setTimeout(() => {
      debouncedValue.value = newValue
    }, delay)
  })

  return debouncedValue
}

// src/composables/useLocalStorage.js
import { ref, watch } from 'vue'

export function useLocalStorage(key, defaultValue = null) {
  const stored = localStorage.getItem(key)
  const initialValue = stored ? JSON.parse(stored) : defaultValue
  
  const storedValue = ref(initialValue)

  // –°–ª–µ–¥–∏–º –∑–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage
  watch(
    storedValue,
    (newValue) => {
      if (newValue === null || newValue === undefined) {
        localStorage.removeItem(key)
      } else {
        localStorage.setItem(key, JSON.stringify(newValue))
      }
    },
    { deep: true }
  )

  // –°–ª—É—à–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –≤–∫–ª–∞–¥–∫–∞—Ö
  window.addEventListener('storage', (e) => {
    if (e.key === key) {
      storedValue.value = e.newValue ? JSON.parse(e.newValue) : defaultValue
    }
  })

  return storedValue
}

// src/composables/useValidation.js
import { ref, computed } from 'vue'

export function useValidation(rules = {}) {
  const values = ref({})
  const errors = ref({})
  const touched = ref({})

  const isValid = computed(() => {
    return Object.keys(errors.value).length === 0
  })

  const hasErrors = computed(() => {
    return Object.keys(errors.value).some(key => touched.value[key])
  })

  const validateField = (fieldName, value) => {
    const fieldRules = rules[fieldName]
    if (!fieldRules) return true

    let error = null

    for (const rule of fieldRules) {
      if (typeof rule === 'function') {
        const result = rule(value)
        if (result !== true) {
          error = result
          break
        }
      }
    }

    if (error) {
      errors.value[fieldName] = error
    } else {
      delete errors.value[fieldName]
    }

    return !error
  }

  const validate = () => {
    let isFormValid = true
    
    Object.keys(rules).forEach(fieldName => {
      const fieldValue = values.value[fieldName]
      const isFieldValid = validateField(fieldName, fieldValue)
      if (!isFieldValid) {
        isFormValid = false
      }
    })

    return isFormValid
  }

  const setValue = (fieldName, value) => {
    values.value[fieldName] = value
    validateField(fieldName, value)
  }

  const setTouched = (fieldName, isTouched = true) => {
    touched.value[fieldName] = isTouched
  }

  const reset = () => {
    values.value = {}
    errors.value = {}
    touched.value = {}
  }

  const getError = (fieldName) => {
    return touched.value[fieldName] ? errors.value[fieldName] : null
  }

  return {
    values,
    errors,
    touched,
    isValid,
    hasErrors,
    validateField,
    validate,
    setValue,
    setTouched,
    reset,
    getError
  }
}

// src/composables/useDragAndDrop.js
import { ref } from 'vue'

export function useDragAndDrop() {
  const draggedItem = ref(null)
  const dragOverItem = ref(null)
  const isDragging = ref(false)

  const startDrag = (item, event) => {
    draggedItem.value = item
    isDragging.value = true
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è drag & drop
    if (event?.dataTransfer) {
      event.dataTransfer.effectAllowed = 'move'
      event.dataTransfer.setData('application/json', JSON.stringify(item))
    }
  }

  const endDrag = () => {
    draggedItem.value = null
    dragOverItem.value = null
    isDragging.value = false
  }

  const onDragOver = (item, event) => {
    if (event) {
      event.preventDefault()
      event.dataTransfer.dropEffect = 'move'
    }
    dragOverItem.value = item
  }

  const onDragLeave = () => {
    dragOverItem.value = null
  }

  const onDrop = (targetItem, event, callback) => {
    if (event) {
      event.preventDefault()
    }

    const sourceItem = draggedItem.value
    if (sourceItem && targetItem && sourceItem !== targetItem) {
      if (callback) {
        callback(sourceItem, targetItem)
      }
    }

    endDrag()
  }

  const canDrop = (targetItem) => {
    return draggedItem.value && draggedItem.value !== targetItem
  }

  return {
    draggedItem,
    dragOverItem,
    isDragging,
    startDrag,
    endDrag,
    onDragOver,
    onDragLeave,
    onDrop,
    canDrop
  }
}

// src/composables/useExport.js
import { ref } from 'vue'
import { exportService } from '@/services/exportService'
import { useToast } from './useToast'

export function useExport() {
  const isExporting = ref(false)
  const { success, error } = useToast()

  const exportToPDF = async (estimate, options = {}) => {
    if (!estimate) {
      error('–û—à–∏–±–∫–∞', '–ù–µ –≤—ã–±—Ä–∞–Ω–∞ —Å–º–µ—Ç–∞ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞')
      return
    }

    try {
      isExporting.value = true
      
      const pdfBlob = await exportService.exportToPDF(estimate, options)
      const filename = `${estimate.tourInfo.tourName || '–°–º–µ—Ç–∞'}_${estimate.id}.pdf`
      
      exportService.downloadFile(pdfBlob, filename)
      success('–≠–∫—Å–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à–µ–Ω', 'PDF —Ñ–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω')
    } catch (err) {
      error('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞', err.message)
    } finally {
      isExporting.value = false
    }
  }

  const exportToExcel = async (estimate) => {
    if (!estimate) {
      error('–û—à–∏–±–∫–∞', '–ù–µ –≤—ã–±—Ä–∞–Ω–∞ —Å–º–µ—Ç–∞ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞')
      return
    }

    try {
      isExporting.value = true
      
      const excelBlob = await exportService.exportToExcel(estimate)
      const filename = `${estimate.tourInfo.tourName || '–°–º–µ—Ç–∞'}_${estimate.id}.xlsx`
      
      exportService.downloadFile(excelBlob, filename)
      success('–≠–∫—Å–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à–µ–Ω', 'Excel —Ñ–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω')
    } catch (err) {
      error('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞', err.message)
    } finally {
      isExporting.value = false
    }
  }

  const exportToCSV = (estimate) => {
    if (!estimate) {
      error('–û—à–∏–±–∫–∞', '–ù–µ –≤—ã–±—Ä–∞–Ω–∞ —Å–º–µ—Ç–∞ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞')
      return
    }

    try {
      const csvContent = exportService.generateCSVContent(estimate)
      const csvBlob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
      const filename = `${estimate.tourInfo.tourName || '–°–º–µ—Ç–∞'}_${estimate.id}.csv`
      
      exportService.downloadFile(csvBlob, filename)
      success('–≠–∫—Å–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à–µ–Ω', 'CSV —Ñ–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω')
    } catch (err) {
      error('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞', err.message)
    }
  }

  return {
    isExporting,
    exportToPDF,
    exportToExcel,
    exportToCSV
  }
}

// src/composables/useCurrency.js
import { computed } from 'vue'
import { currencyService } from '@/services/currencyService'
import { useSettingsStore } from '@/stores/settingsStore'

export function useCurrency() {
  const settingsStore = useSettingsStore()

  const currentCurrency = computed(() => settingsStore.currency)
  const currencies = computed(() => currencyService.getAllCurrencies())

  const formatAmount = (amount, currency = null) => {
    const targetCurrency = currency || currentCurrency.value
    return currencyService.formatAmount(amount, targetCurrency)
  }

  const convertAmount = (amount, fromCurrency, toCurrency = null) => {
    const targetCurrency = toCurrency || currentCurrency.value
    return currencyService.convertAmount(amount, fromCurrency, targetCurrency)
  }

  const getCurrencySymbol = (currency = null) => {
    const targetCurrency = currency || currentCurrency.value
    const currencyInfo = currencyService.getCurrency(targetCurrency)
    return currencyInfo.symbol
  }

  const setCurrency = (newCurrency) => {
    settingsStore.updateCurrency(newCurrency)
  }

  return {
    currentCurrency,
    currencies,
    formatAmount,
    convertAmount,
    getCurrencySymbol,
    setCurrency
  }
}